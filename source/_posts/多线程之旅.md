---
title: 多线程之九阳神功秘籍 
author: codejenny
top: false
cover: false
categories: 
tags: 技术
date: 2020-07-11 11:20:23 
img: 
coverImg:
password:
summary: 日常学习之多线程的学习之路
keywords:
mathjax: false
toc: true
---


# 多线程之旅

---

## 什么是多线程？
我们先来看看，什么是线程：

![](http://qd343r17a.bkt.clouddn.com//img/20200710152151.png)

**问题1：不运行的程序，是什么？**

> 程序可以理解成一个静态的指令集合，当系统运行程序时， 程序中的指令就被激活了，转变成进程开始执行任务。

**问题2：进程之间会相互影响吗？**

> 1. 进程是系统中独立存在的实体，每一个进程都拥有自己私有的地址空间。在没有经过进程本身的允许的情况下，一个用户进程是不可以直接访问其他进程的地址空间的；
> 2. 多个进程可以在单个处理器上并发执行，并且多进程之间不会互相影响。

**问题3：线程之间会互相影响吗？**
> 线程可以理解成进程的执行单元，一个线程必须有一个父进程，当进程被初始化，主线程就创建了，它们共享着父进程的内存资源。线程可以拥有自己的堆栈，自己的程序计数器和自己的局部变量，但不拥有系统资源；他们可以通过调用父线程的资源来相互影响，但是要做到不要相互妨碍；

> 总结起来就是一句话，一个程序的运行，至少依托着一个进程的支持，一个进程的运行，至少需要一个线程；

**多线程的优势(相较于多进程)**
```
1. 进程之间不能共享内存，线程之间能轻易实现内存的共享；

2. 系统创建进程需要为该进程重新分配系统资源，而创建线程的代价相比之下就小得多，因此使用多线程来实现任务并发就比多进程的效率高；

3. Java语言内置了多线程功能的支持，而不是单纯地作为底层操作系统的调度方式，从而简化了Java的多线程编程。
```
## 线程的创建与启动
>三种方法：1. 继承Thread类创建；2. 实现Runnable接口创建；3. 使用Callable和Future创建

### 第一种继承创建

见如下代码：
```
public class Demo1 {
    public static void main(String[] args) {
        Thread t = new MyThread();
        t.start();
        for(int i =0;i<100;i++)
            System.out.println(Thread.currentThread().getName()+"多线程不好玩");
    }
    static class MyThread extends Thread{
        @Override
        public void run() {
            for(int i =0;i<100;i++)
                System.out.println(Thread.currentThread().getName()+"多线程真好玩");
        }
    }
}
```
>运行结果中能看到交替运行:
![](http://qd343r17a.bkt.clouddn.com//img/20200710162128.png)

> 当然，这么写有点麻烦，因为Mythread子类只用了一次，可以创建匿名内部类的形式简化上述代码:
```
public class Demo1 {
    public static void main(String[] args) {
        new Thread(){
            @Override
            public void run() {
                for (int i = 0;i<100;i++){
                    System.out.println("多线程好玩:"+i);
                }
            }
        }.start();
        for (int i = 0;i<10;i++){
            System.out.println("多线程真好玩:"+i);
        }
    }
}
```
### 第二种Runnable接口创建（最常用）
```
直接上代码
public class Demo1 {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0;i<100;i++)
                    System.out.println(Thread.currentThread().getName()+"多线程真好玩");
            }
        }).start();
        for (int i = 0;i<100;i++)
            System.out.println(Thread.currentThread().getName()+"多线程不好玩");
    }
}
```
> 由于这个Runnable 接口只有run这一个方法需要实现，所以可以利用**Lambda**表达式来进一步简化：

```
public class Demo1 {
    public static void main(String[] args) {
        new Thread(()->{
                for (int i = 0;i<100;i++)
                    System.out.println(Thread.currentThread().getName()+"多线程真好玩"+i);
        }).start();
        for (int i = 0;i<100;i++)
            System.out.println(Thread.currentThread().getName()+"多线程不好玩"+i);
    }
}
```
### 第三种Callalbe创建（带有返回值的接口线程创建）
```
public class Demo2 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable<Integer> c = new MyCallable<>();
        FutureTask<Integer> task = new FutureTask<>(c);
        new Thread(task).start();
        System.out.println("子线程的返回值为："+task.get());
        for(int i = 0;i<10;i++)
            System.out.println(i);
    }
    static class MyCallable<Interger> implements Callable {
        @Override
        public Object call() throws Exception {
            for(int i = 0;i<10;i++)
                System.out.println(i);
            return 100;
        }
    }
}
```
> 注意：如果子线程与主线程之间存在 task.get() 获取子线程的返回值，主线程会等待返回值得到，也就是子线程执行完，再开始执行主线程；
如果想停止子线程的运行，通过task.cancel()来停止

### 三种创建方法的比较
>Thread继承与Runnable创建比较
![](http://qd343r17a.bkt.clouddn.com//img/20200710172644.png)
Runnable 与 Callable 比较：
Runnable不带返回值，代码实现简单，对主线程影响较小;
而Callable带返回值，除了实现call方法外，还要用FutureTask 类来实现返回值的调用，并且调取get()方法会引起主线程阻塞；

## 线程的生命周期
> 按照老师的课程，线程的执行过程中，有一下6种状态：New(新建状态)，Runnable(运行状态)，Blocker(阻塞状态)，Waiting/TimedWaiting(有限等待、无限等待状态)，Teminated(终止状态)

![](http://qd343r17a.bkt.clouddn.com//img/20200710174520.png)

> 查阅了相关书籍后，我觉得按照这个图来形容来划分比较合理：

![](http://qd343r17a.bkt.clouddn.com//img/20200711095406.png)

> 为什么start()后要划分成就绪跟运行状态？
由于线程启动后，不会一直“霸占”着CPU来执行，CPU会在多线程之间来回切换，所以线程也会在运行，就绪之间往复交替；

## 控制线程

> **设置守护线程：**
(线程的引用)t.setDaemon(true)
守护线程的概念，守护线程也可以叫后台线程，其特征为：当所有的前台线程死亡后，后台线程自动结束，（）内输入 true 为设置成守护线程，不输入或者输入false,为不设置；
JVM 的垃圾回收就是典型的后台线程;

> **让线程按下暂停键**
Thread.sleep()
在代码中插入`Thread.sleep()`后会使程序暂停一段时间，并进入阻塞状态；相比较而言，yield()方法，这个方法只会让线程重新调度一下，并不会暂停；

> **改变程序的优先级**
Thread.currenttThread().setPriority(5)
赋予线程优先级，优先级高的更容易被执行；
括号内的数值范围是（1-10）,分别对应10种优先级，也可以调用三个静态常量MAX_PRIORITY/NORM_PRIORITY/MIN_PRIORITY（10/5/1）；

## 线程同步

想象这样一个画面：
A , B 同时去银行取钱，然后银行余额都显示1000元，A取500，B取1000，如果 A B两人扣款时间也一样，那银行余额是不是就变成了-500；

这样就是线程同步而引发出来的线程不安全行为；

![](http://qd343r17a.bkt.clouddn.com//img/20200710211748.png)

如何去解决线程不安全：

> **方法1 ：同步代码块**
>
> ```
> 代码如下：
> public class Demo4 {//线程安全性解读一
> 
>     public static void main(String[] args) {
>         Runnable r = new Ticket();
>         new Thread(r).start();
>         new Thread(r).start();
>         new Thread(r).start();
>     }
>     
>     static class Ticket implements Runnable{
>         //总票数
>         private int count = 10 ;
>         private Object o = new Object();
>         @Override
>         public void run() {
>             while (true) {
>                 synchronized (o) {//在执行方法前插入同步代码块sychronized
>                     if(count>0) {
>                         System.out.println(Thread.currentThread().getName() + "准备卖票，总票数为：" + count);
>                         try {
>                             Thread.sleep(1000);
>                         } catch (InterruptedException e) {
>                             e.printStackTrace();
>                         }
>                         count--;
>                         System.out.println("卖票成功，余票为：" + count);
>                     }else
>                         break;
>                 }
>             }
>         }
>     }
> }
> ```
>
> 理解如下：
>
> 当Thread-0/Thread-1/Thread-2 到达if 循环前，最先到达的那个线程会被套上 sychronized 给的标记 o，当标记 o 激活时，假定最先到达的是Thread-0，Thread-1/Thread-2 会在原地等待，等待标记消失后再向下执行，而当Thread-0执行完成if中的语句后，标记会被清除，Thread-0会随着循环再一次来到if前，而标记清除后，Thread-1/Thread-2 接收到标记消失命令，再开始往下执行；这个时候谁会执行是不一定的，取决于谁能争抢到时间片；

> **方法2 ：同步方法**
>
> 将if后面的代码打包成一个方法，然后用synchronized进行修饰（准确说是进行装饰），代码如下
>
> ```
> public class Demo5 {//线程安全性解读
> 
>     public static void main(String[] args) {
>         Runnable r = new Ticket();
>         new Thread(r).start();
>         new Thread(r).start();
>         new Thread(r).start();
>     }
>     static class Ticket implements Runnable{
>         //总票数
>         private int count = 10 ;
>         @Override
>         public void run() {
>             while (true) {
>                 this.sale();
>                 if(count == 0)
>                     break;
>             }
>         }
>         public synchronized void sale(){//用synchronized修饰sale()方法，依然放在if前
>             if(count>0) {
>                 System.out.println(Thread.currentThread().getName() + "准备卖票，总票数为：" + count);
>                 try {
>                     Thread.sleep(1000);
>                 } catch (InterruptedException e) {
>                     e.printStackTrace();
>                 }
>                 count--;
>                 System.out.println("卖票成功，余票为：" + count);
>             }
>         }
>     }
> }
> ```

> **方法3 ：添加显示锁**
>
> 上述的两种方式相当于是隐式锁的概念，从Java 5 开始，Java官方添加了一种更强大的线程同步机制——同步锁，由Lock对象充当；
>
> 同步锁一般比较常用的是Lock对象的实现类ReentrantLock（可重入锁），代码如下
>
> ```
> public class Demo6 {//线程安全性解读
> 
>        public static void main(String[] args) {
>            Runnable r = new Ticket();
>            new Thread(r).start();
>            new Thread(r).start();
>            new Thread(r).start();
>        }
>        static class Ticket implements Runnable{
>            //总票数
>            private int count = 10 ;
>            private Lock l = new ReentrantLock(true);
>            @Override
>            public void run() {
>                while (true) {
>                    l.lock();
>                    try {
>                        if (count > 0) {
>                            System.out.println(Thread.currentThread().getName() + "准备卖票，总票数为：" + count);
>                            Thread.sleep(1000);
>                            count--;
>                            System.out.println("卖票成功，余票为：" + count);
>                        } else
>                            break;
>                    }catch(InterruptedException e){
>                        e.printStackTrace();
>                    }finally{
>                        l.unlock();
>                    }
>                }
>            }
>        }
>    }
>    ```

> ReentrantLock() 括号内可传入boolean 参数，传入true后，锁就变成了公平锁，会让线程排队执行，以上述为例，会依次Thread -0（假设0线程第一个执行）、Thread-1(假设第二个执行)、Thread-2(第三个执行)，会依次 0/1/2、0/1/2的顺序（当然也可以102,201的顺序，取决于谁先抢到时间片，但第一次循环后，顺序就固定下来了）执行，直至线程结束； 

> **死锁**

在线程同步中，添加同步监视器过多，可能会导致死锁的现象；

可以这样来理解：在A 运行的代码中加入B的锁，等待B解锁后才能向下执行；又在B运行的代码中加入A 的锁，等待 A 解锁后才向下执行，假如 A 等待 B 的时候，B又在等待 A ，这样死锁就产生了；

一旦死锁产生，整个程序不会出错，也没有任何提示，整个处于阻塞的状态，无法继续。

## 线程通信

> **生产者和消费者问题：**

A 是生产者，负责生产食物和数量，B 是消费者，负责接收食物和数量，想象一个场景，假如 A 生产两种食物，循环递给B，B负责消费，消费完成后 ，通知A 进行生产 ，依次按顺序循环100次，怎样进行如上的代码实现呢；

方法一：

Object 类有三个有助于线程通信的方法，wait() 使当前线程等待，notify() 随机唤醒一个线程，notifyAll()，唤醒所有线程；

利用这三个方法，再加上标签flag = ture /false ，可以很好的实现如上代码需求；具体代码就不展示了，有点占篇幅；

方法二：

使用BlockingQueue（阻塞队列）

put() 把元素放入队列，如果队列已满，则阻塞该线程

take() 从队列头取走元素，如果队列已空，则阻塞线程；

这个不是太会；后面再研究

## 线程池

> **为什么需要线程池？**

1.  系统创建一个新线程的耗费是很大的，而运行一个线程耗费要小很多，运用线程池的概念，可以很好的提升系统性能；
2.  线程池可以很好的控制系统中并发线程的数量，即在创建初直接指定并发执行的线程数；
3.  线程池能提供定时执行、定期执行、单线程、并发数控制等功能

> **四种线程池的创建**

第一种，缓存线程池：

`newCachedThreadPool()`，创建一个具有缓存功能的线程池，可灵活回收空闲线程；

第二种，定长线程池：

`newFixedThreadPool(初始线程数)`，初始线程数一旦被固定，就只能使固定数量的线程并发运行；

第三种，单线程线程池

`newSingleThreadExecutor()` ，创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务

第四种，周期执行线程池

`newScheduledThreadPool()`，创建一个定长线程池，支持定时及周期性任务执



## 多线程面试题

参考链接：[50个多线程面试题汇总](https://blog.csdn.net/cmyperson/article/details/79610870)

**什么是线程？**

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。

比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒

**什么是线程安全和线程不安全？**

线程安全: 就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染

线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据

**什么是自旋锁？**

当线程A想要获取一把自旋锁而该锁又被其它线程锁持有时，线程A会在一个循环中自旋以检测锁是不是已经可用了

**什么是乐观锁和悲观锁？**

悲观锁

Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。

乐观锁

乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做

==============================

还有很多题目，详见参考链接，就不一一赘述了；



全剧终